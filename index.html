<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>í¼ì¦ ë§ì¶”ê¸° ê²Œì„ (6ì¡°ê°) - í„°ì¹˜ ì§€ì› V2</title>
<style>
  body {
    background-color: #f0f8ff;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    overflow: hidden;
    flex-direction: column;
    position: relative;
    /* âš¡ï¸ ì¤‘ìš”: CSSì—ì„œ ëª¨ë“  í„°ì¹˜ ë™ì‘ ê¸°ë³¸ ë°©ì§€ */
    touch-action: none; 
    /* ë“œë˜ê·¸ ì¤‘ ì»¤ì„œ ë³€ê²½ (ë°ìŠ¤í¬í†±ìš©) */
    cursor: default; 
  }
  #gameCanvas {
    background-color: white;
    border: none;
    border-radius: 16px;
    display: block;
    margin: 0 auto;
    z-index: 10;
  }

  #winOverlay {
    display: none;
    width: 1200px;
    margin-top: 20px;
    z-index: 20; 
    justify-content: center;
    align-items: center;
    flex-direction: column;
    text-align: center; 
  }
  #winMessage {
    color: #0b3b8c; 
    font-size: 48px; 
    font-family: 'Arial Black', sans-serif;
    padding: 20px 40px;
    border-radius: 10px;
    background-color: rgba(255, 255, 255, 0.9);
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="1200" height="700"></canvas>

<div id="winOverlay" style="display: none;">
    <div id="winMessage"></div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const winOverlay = document.getElementById("winOverlay");

// ì´ë¯¸ì§€ ë¡œë“œ (ê²½ë¡œëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€)
const backgroundImg = new Image();
backgroundImg.src = "./images/background.png";

const puzzleImgs = [];
for (let i = 1; i <= 6; i++) {
  const img = new Image();
  img.src = `./images/puzzle${i}.png`;
  puzzleImgs.push(img);
}
const winImg = new Image();
winImg.src = "./images/win.png";

// ì‚¬ìš´ë“œ ë³µêµ¬ ë° ë¡œë“œ
const fallSound = new Audio("./sounds/fall.mp3");
const successSound = new Audio("./sounds/success.mp3");

// ì‚¬ìš´ë“œ ë³¼ë¥¨ ì„¤ì • (í•„ìš”ì— ë”°ë¼)
fallSound.volume = 1.0;
successSound.volume = 1.0;


// í¬ê¸° ë¹„ìœ¨
const scale = 0.35;
const bgWidth = 1920 * scale; 
const bgHeight = 1078 * scale; 
const puzzleWidth = 604 * scale; 
const puzzleHeight = 508 * scale; 

// í¼ì¦ ì •ë‹µ ìœ„ì¹˜
const yOffset = 20; 
const canvasBgOffsetX = (canvas.width - bgWidth) / 2; 

const targetPositions = [
  {x: 38*scale + canvasBgOffsetX, y: 27*scale + yOffset},
  {x: (38+604+23)*scale + canvasBgOffsetX, y: 27*scale + yOffset},
  {x: (38+604+23+604+19)*scale + canvasBgOffsetX, y: 27*scale + yOffset},
  {x: 38*scale + canvasBgOffsetX, y: (27+508+15)*scale + yOffset},
  {x: (38+604+23)*scale + canvasBgOffsetX, y: (27+508+15)*scale + yOffset},
  {x: (38+604+23+604+19)*scale + canvasBgOffsetX, y: (27+508+15)*scale + yOffset},
];

// í•˜ë‹¨ ê²¹ì³ì§„ ê¸°ë³¸ ìœ„ì¹˜ (ê°„ê²© 10px ìœ ì§€)
const maxBgY = yOffset + bgHeight; 
const VERTICAL_GAP = 10; 
const initialY_single_row = maxBgY + VERTICAL_GAP; 

const overlapSpacing = puzzleWidth * 0.3; 
const totalPieces = 6;
const totalWidth = totalPieces * overlapSpacing + (puzzleWidth - overlapSpacing); 

const startBaseX = (canvas.width - totalWidth) / 2; 

const basePositions = [];
for (let i = 0; i < totalPieces; i++) {
    basePositions.push({
        x: startBaseX + (i * overlapSpacing), 
        y: initialY_single_row 
    });
}


// ë¬´ì‘ìœ„ ì„ê¸°
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

const shuffledOriginalIndices = shuffle(Array.from({length: 6}, (_, i) => i));

// í¼ì¦ ì´ˆê¸° ìœ„ì¹˜ë¥¼ ì„ì¸ ì›ë³¸ ì¸ë±ìŠ¤ì— ë”°ë¼ ë°°ì¹˜
const puzzlePieces = shuffledOriginalIndices.map((originalIndex, shuffledPosIndex) => ({
  x: basePositions[shuffledPosIndex].x,
  y: basePositions[shuffledPosIndex].y,
  originalIndex: originalIndex,
  placed: false
}));

let dragging = false;
let dragIndex = -1;
let offsetDragX = 0, offsetDragY = 0;

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // ë°°ê²½ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
  ctx.drawImage(backgroundImg, canvasBgOffsetX, yOffset, bgWidth, bgHeight);
  
  // í¼ì¦ ì¡°ê° ê·¸ë¦¬ê¸°
  puzzlePieces.forEach((p) => {
    const img = puzzleImgs[p.originalIndex];
    ctx.drawImage(img, p.x, p.y, puzzleWidth, puzzleHeight);
  });
}

// ----------------------------------------------------
// ğŸ¯ í„°ì¹˜ ë° ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ í†µí•© ë¡œì§ (ì•ˆì •ì„± ê°•í™”)
// ----------------------------------------------------

/**
 * ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ë‚˜ í„°ì¹˜ ì´ë²¤íŠ¸ì—ì„œ ìº”ë²„ìŠ¤ ë‚´ë¶€ ìƒëŒ€ ì¢Œí‘œë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.
 */
function getEventCoords(e) {
  const rect = canvas.getBoundingClientRect();
  let clientX, clientY;

  // âš¡ï¸ ì¤‘ìš”: í„°ì¹˜ ì´ë²¤íŠ¸ëŠ” touches ë°°ì—´ì„ ì‚¬ìš©í•˜ë©°, ì—†ì„ ê²½ìš° ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ë¡œ ê°„ì£¼
  if (e.touches && e.touches.length > 0) {
    clientX = e.touches[0].clientX;
    clientY = e.touches[0].clientY;
  } else if (e.changedTouches && e.changedTouches.length > 0) {
     // touchend ì´ë²¤íŠ¸ ì²˜ë¦¬ë¥¼ ìœ„í•´ changedTouches ì‚¬ìš©
    clientX = e.changedTouches[0].clientX;
    clientY = e.changedTouches[0].clientY;
  }
  else {
    clientX = e.clientX;
    clientY = e.clientY;
  }
  
  // ìº”ë²„ìŠ¤ ë‚´ë¶€ ì¢Œí‘œë¡œ ë³€í™˜
  const offsetX = clientX - rect.left;
  const offsetY = clientY - rect.top;
  
  return { offsetX, offsetY };
}

// ë“œë˜ê·¸ ì‹œì‘ (mousedown, touchstart)
function handleDragStart(e) {
  // âš¡ï¸ ì¤‘ìš”: í„°ì¹˜ ë° ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ì˜ ê¸°ë³¸ ë™ì‘(ìŠ¤í¬ë¡¤, ì¤Œ ë“±) ë¬´ì¡°ê±´ ë°©ì§€
  e.preventDefault(); 
  
  // ì´ë¯¸ ë“œë˜ê·¸ ì¤‘ì¸ ê²½ìš° ë¬´ì‹œ (ë‹¤ì¤‘ í„°ì¹˜ ë°©ì§€)
  if (dragging) return;


  const { offsetX: mx, offsetY: my } = getEventCoords(e);
  let found = false;

  for (let i = puzzlePieces.length - 1; i >= 0; i--) {
    const p = puzzlePieces[i];
    if (p.placed) continue;

    if (mx >= p.x && mx <= p.x + puzzleWidth &&
        my >= p.y && my <= p.y + puzzleHeight) {
      dragging = true;
      
      // ë°°ì—´ì—ì„œ ì¡°ê°ì„ ë¹¼ì„œ ë§¨ ë’¤ë¡œ ì´ë™ (z-index íš¨ê³¼)
      const pieceToDrag = puzzlePieces.splice(i, 1)[0];
      puzzlePieces.push(pieceToDrag);
      dragIndex = puzzlePieces.length - 1;
      
      offsetDragX = mx - pieceToDrag.x;
      offsetDragY = my - pieceToDrag.y;
      found = true;
      break;
    }
  }
  if (found) draw();
}

// ë“œë˜ê·¸ ì¤‘ (mousemove, touchmove)
function handleDragMove(e) {
  if (dragging && dragIndex !== -1) {
    // âš¡ï¸ ì¤‘ìš”: ì´ë™ ì¤‘ì—ë„ ê¸°ë³¸ ë™ì‘ ë°©ì§€
    e.preventDefault(); 
    
    const { offsetX: mx, offsetY: my } = getEventCoords(e);
    puzzlePieces[dragIndex].x = mx - offsetDragX;
    puzzlePieces[dragIndex].y = my - offsetDragY;
    draw();
  }
}

// ë“œë˜ê·¸ ë (mouseup, touchend)
function handleDragEnd(e) {
  // âš¡ï¸ ì¤‘ìš”: í„°ì¹˜ ì´ë²¤íŠ¸ê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¼
  if (e.touches && e.touches.length > 0) return; 

  if (dragging && dragIndex !== -1) {
    // touchend ì´ë²¤íŠ¸ ì‹œ ì¢Œí‘œë¥¼ ì–»ê¸° ìœ„í•´ getEventCoordsë¥¼ í˜¸ì¶œí•  í•„ìš”ê°€ ì—†ìœ¼ë¯€ë¡œ ìƒëµ
    
    const piece = puzzlePieces[dragIndex];
    const target = targetPositions[piece.originalIndex];

    // ë“œë˜ê·¸ ì¢…ë£Œ ì‹œì ì˜ ì¢Œí‘œë¥¼ ì‚¬ìš©
    const dx = piece.x - target.x;
    const dy = piece.y - target.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    const snapTolerance = 40;

    if (distance < snapTolerance) {
      // âœ… ì •ë‹µ ìœ„ì¹˜ ìŠ¤ëƒ…
      piece.x = target.x;
      piece.y = target.y;
      piece.placed = true;
      successSound.currentTime = 0; 
      successSound.play(); 
      checkAllPlaced();
    } else {
      // âŒ ì˜¤ë‹µ, ì›ë˜ ìë¦¬ë¡œ ë³µê·€
      fallSound.currentTime = 0; 
      fallSound.play(); 

      const startX = piece.x;
      const startY = piece.y;
      
      const originalShuffledPosIndex = shuffledOriginalIndices.indexOf(piece.originalIndex);
      const originalBasePos = basePositions[originalShuffledPosIndex];
      const endX = originalBasePos.x;
      const endY = originalBasePos.y;
      
      let progress = 0;

      function returnAnim() {
        progress += 0.1;
        piece.x = startX + (endX - startX) * progress;
        piece.y = startY + (endY - startY) * progress;
        draw();
        if (progress < 1) requestAnimationFrame(returnAnim);
      }
      requestAnimationFrame(returnAnim);
    }
  }
  dragging = false;
  dragIndex = -1;
  draw();
}

// ----------------------------------------------------
// âš¡ï¸ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ (documentì— move/end ë“±ë¡)
// ----------------------------------------------------

// ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸: ìº”ë²„ìŠ¤ì—ì„œ ì‹œì‘, ì–´ë””ì„œë“  ì´ë™/ë
canvas.addEventListener("mousedown", handleDragStart);
document.addEventListener("mousemove", handleDragMove); // documentë¡œ ë³€ê²½
document.addEventListener("mouseup", handleDragEnd); 

// í„°ì¹˜ ì´ë²¤íŠ¸: ìº”ë²„ìŠ¤ì—ì„œ ì‹œì‘, ì–´ë””ì„œë“  ì´ë™/ë
canvas.addEventListener("touchstart", handleDragStart);
document.addEventListener("touchmove", handleDragMove); // documentë¡œ ë³€ê²½
document.addEventListener("touchend", handleDragEnd); 


// ----------------------------------------------------
// ğŸ§© í¼ì¦ ì™„ì„± ë° ì• ë‹ˆë©”ì´ì…˜ ë¡œì§ (ê¸°ì¡´ê³¼ ë™ì¼)
// ----------------------------------------------------

// í¼ì¦ ì™„ì„± ì²´í¬ ë° ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜
function checkAllPlaced() {
  if (puzzlePieces.filter(p => p.placed).length === 6) {
    canvas.style.pointerEvents = 'none'; // ë” ì´ìƒ í´ë¦­ ë¶ˆê°€
    
    setTimeout(() => {
      successSound.currentTime = 0; 
      successSound.play(); 
      startWipeAnimation(); // ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰
    }, 500);
  }
}

// 'ë‹¦ì•„ë‚´ê¸°' ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜
function startWipeAnimation() {
  let wipeProgress = 0;
  const duration = 120; 
  let frame = 0;

  function animateWipe() {
    frame++;
    if (frame > duration) {
      // ìº”ë²„ìŠ¤ ì¤‘ì•™ì— ë©”ì‹œì§€ ë„ìš°ê¸° (ì˜µì…˜)
      winOverlay.style.display = 'flex';
      winMessage.textContent = "í¼ì¦ ì™„ì„±!";
      return;
    }

    wipeProgress = bgWidth * (frame / duration);

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // ì™„ì„±ëœ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
    ctx.drawImage(winImg, canvasBgOffsetX, yOffset, bgWidth, bgHeight);
    
    // ë‹¦ì•„ë‚´ëŠ” íš¨ê³¼ (í°ìƒ‰ ì‚¬ê°í˜•ìœ¼ë¡œ ê°€ë¦¬ê¸°)
    let clipX = canvasBgOffsetX + wipeProgress;
    let clipW = bgWidth - wipeProgress;
    
    ctx.fillStyle = 'white'; 
    ctx.fillRect(clipX, yOffset, clipW, bgHeight);

    requestAnimationFrame(animateWipe);
  }

  if (winImg.complete) {
    animateWipe();
  } else {
    winImg.onload = animateWipe;
  }
}


// ì´ë¯¸ì§€ ë¡œë“œ í›„ ê·¸ë¦¬ê¸°
let loadedCount = 0;
const totalImages = 1 + puzzleImgs.length + 1; 
function checkLoaded() {
  loadedCount++;
  if (loadedCount === totalImages) draw();
}
backgroundImg.onload = checkLoaded;
winImg.onload = checkLoaded;
puzzleImgs.forEach(img => img.onload = checkLoaded);
</script>
</body>
</html>
