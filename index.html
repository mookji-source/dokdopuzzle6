<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>퍼즐 맞추기 게임 (6조각) - 터치 지원 V2</title>
<style>
  body {
    background-color: #f0f8ff;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    overflow: hidden;
    flex-direction: column;
    position: relative;
    /* ⚡️ 중요: CSS에서 모든 터치 동작 기본 방지 */
    touch-action: none; 
    /* 드래그 중 커서 변경 (데스크톱용) */
    cursor: default; 
  }
  #gameCanvas {
    background-color: white;
    border: none;
    border-radius: 16px;
    display: block;
    margin: 0 auto;
    z-index: 10;
  }

  #winOverlay {
    display: none;
    width: 1200px;
    margin-top: 20px;
    z-index: 20; 
    justify-content: center;
    align-items: center;
    flex-direction: column;
    text-align: center; 
  }
  #winMessage {
    color: #0b3b8c; 
    font-size: 48px; 
    font-family: 'Arial Black', sans-serif;
    padding: 20px 40px;
    border-radius: 10px;
    background-color: rgba(255, 255, 255, 0.9);
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="1200" height="700"></canvas>

<div id="winOverlay" style="display: none;">
    <div id="winMessage"></div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const winOverlay = document.getElementById("winOverlay");

// 이미지 로드 (경로는 그대로 유지)
const backgroundImg = new Image();
backgroundImg.src = "./images/background.png";

const puzzleImgs = [];
for (let i = 1; i <= 6; i++) {
  const img = new Image();
  img.src = `./images/puzzle${i}.png`;
  puzzleImgs.push(img);
}
const winImg = new Image();
winImg.src = "./images/win.png";

// 사운드 복구 및 로드
const fallSound = new Audio("./sounds/fall.mp3");
const successSound = new Audio("./sounds/success.mp3");

// 사운드 볼륨 설정 (필요에 따라)
fallSound.volume = 1.0;
successSound.volume = 1.0;


// 크기 비율
const scale = 0.35;
const bgWidth = 1920 * scale; 
const bgHeight = 1078 * scale; 
const puzzleWidth = 604 * scale; 
const puzzleHeight = 508 * scale; 

// 퍼즐 정답 위치
const yOffset = 20; 
const canvasBgOffsetX = (canvas.width - bgWidth) / 2; 

const targetPositions = [
  {x: 38*scale + canvasBgOffsetX, y: 27*scale + yOffset},
  {x: (38+604+23)*scale + canvasBgOffsetX, y: 27*scale + yOffset},
  {x: (38+604+23+604+19)*scale + canvasBgOffsetX, y: 27*scale + yOffset},
  {x: 38*scale + canvasBgOffsetX, y: (27+508+15)*scale + yOffset},
  {x: (38+604+23)*scale + canvasBgOffsetX, y: (27+508+15)*scale + yOffset},
  {x: (38+604+23+604+19)*scale + canvasBgOffsetX, y: (27+508+15)*scale + yOffset},
];

// 하단 겹쳐진 기본 위치 (간격 10px 유지)
const maxBgY = yOffset + bgHeight; 
const VERTICAL_GAP = 10; 
const initialY_single_row = maxBgY + VERTICAL_GAP; 

const overlapSpacing = puzzleWidth * 0.3; 
const totalPieces = 6;
const totalWidth = totalPieces * overlapSpacing + (puzzleWidth - overlapSpacing); 

const startBaseX = (canvas.width - totalWidth) / 2; 

const basePositions = [];
for (let i = 0; i < totalPieces; i++) {
    basePositions.push({
        x: startBaseX + (i * overlapSpacing), 
        y: initialY_single_row 
    });
}


// 무작위 섞기
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

const shuffledOriginalIndices = shuffle(Array.from({length: 6}, (_, i) => i));

// 퍼즐 초기 위치를 섞인 원본 인덱스에 따라 배치
const puzzlePieces = shuffledOriginalIndices.map((originalIndex, shuffledPosIndex) => ({
  x: basePositions[shuffledPosIndex].x,
  y: basePositions[shuffledPosIndex].y,
  originalIndex: originalIndex,
  placed: false
}));

let dragging = false;
let dragIndex = -1;
let offsetDragX = 0, offsetDragY = 0;

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // 배경 이미지 그리기
  ctx.drawImage(backgroundImg, canvasBgOffsetX, yOffset, bgWidth, bgHeight);
  
  // 퍼즐 조각 그리기
  puzzlePieces.forEach((p) => {
    const img = puzzleImgs[p.originalIndex];
    ctx.drawImage(img, p.x, p.y, puzzleWidth, puzzleHeight);
  });
}

// ----------------------------------------------------
// 🎯 터치 및 마우스 이벤트 통합 로직 (안정성 강화)
// ----------------------------------------------------

/**
 * 마우스 이벤트나 터치 이벤트에서 캔버스 내부 상대 좌표를 추출합니다.
 */
function getEventCoords(e) {
  const rect = canvas.getBoundingClientRect();
  let clientX, clientY;

  // ⚡️ 중요: 터치 이벤트는 touches 배열을 사용하며, 없을 경우 마우스 이벤트로 간주
  if (e.touches && e.touches.length > 0) {
    clientX = e.touches[0].clientX;
    clientY = e.touches[0].clientY;
  } else if (e.changedTouches && e.changedTouches.length > 0) {
     // touchend 이벤트 처리를 위해 changedTouches 사용
    clientX = e.changedTouches[0].clientX;
    clientY = e.changedTouches[0].clientY;
  }
  else {
    clientX = e.clientX;
    clientY = e.clientY;
  }
  
  // 캔버스 내부 좌표로 변환
  const offsetX = clientX - rect.left;
  const offsetY = clientY - rect.top;
  
  return { offsetX, offsetY };
}

// 드래그 시작 (mousedown, touchstart)
function handleDragStart(e) {
  // ⚡️ 중요: 터치 및 마우스 이벤트의 기본 동작(스크롤, 줌 등) 무조건 방지
  e.preventDefault(); 
  
  // 이미 드래그 중인 경우 무시 (다중 터치 방지)
  if (dragging) return;


  const { offsetX: mx, offsetY: my } = getEventCoords(e);
  let found = false;

  for (let i = puzzlePieces.length - 1; i >= 0; i--) {
    const p = puzzlePieces[i];
    if (p.placed) continue;

    if (mx >= p.x && mx <= p.x + puzzleWidth &&
        my >= p.y && my <= p.y + puzzleHeight) {
      dragging = true;
      
      // 배열에서 조각을 빼서 맨 뒤로 이동 (z-index 효과)
      const pieceToDrag = puzzlePieces.splice(i, 1)[0];
      puzzlePieces.push(pieceToDrag);
      dragIndex = puzzlePieces.length - 1;
      
      offsetDragX = mx - pieceToDrag.x;
      offsetDragY = my - pieceToDrag.y;
      found = true;
      break;
    }
  }
  if (found) draw();
}

// 드래그 중 (mousemove, touchmove)
function handleDragMove(e) {
  if (dragging && dragIndex !== -1) {
    // ⚡️ 중요: 이동 중에도 기본 동작 방지
    e.preventDefault(); 
    
    const { offsetX: mx, offsetY: my } = getEventCoords(e);
    puzzlePieces[dragIndex].x = mx - offsetDragX;
    puzzlePieces[dragIndex].y = my - offsetDragY;
    draw();
  }
}

// 드래그 끝 (mouseup, touchend)
function handleDragEnd(e) {
  // ⚡️ 중요: 터치 이벤트가 종료될 때까지 기다림
  if (e.touches && e.touches.length > 0) return; 

  if (dragging && dragIndex !== -1) {
    // touchend 이벤트 시 좌표를 얻기 위해 getEventCoords를 호출할 필요가 없으므로 생략
    
    const piece = puzzlePieces[dragIndex];
    const target = targetPositions[piece.originalIndex];

    // 드래그 종료 시점의 좌표를 사용
    const dx = piece.x - target.x;
    const dy = piece.y - target.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    const snapTolerance = 40;

    if (distance < snapTolerance) {
      // ✅ 정답 위치 스냅
      piece.x = target.x;
      piece.y = target.y;
      piece.placed = true;
      successSound.currentTime = 0; 
      successSound.play(); 
      checkAllPlaced();
    } else {
      // ❌ 오답, 원래 자리로 복귀
      fallSound.currentTime = 0; 
      fallSound.play(); 

      const startX = piece.x;
      const startY = piece.y;
      
      const originalShuffledPosIndex = shuffledOriginalIndices.indexOf(piece.originalIndex);
      const originalBasePos = basePositions[originalShuffledPosIndex];
      const endX = originalBasePos.x;
      const endY = originalBasePos.y;
      
      let progress = 0;

      function returnAnim() {
        progress += 0.1;
        piece.x = startX + (endX - startX) * progress;
        piece.y = startY + (endY - startY) * progress;
        draw();
        if (progress < 1) requestAnimationFrame(returnAnim);
      }
      requestAnimationFrame(returnAnim);
    }
  }
  dragging = false;
  dragIndex = -1;
  draw();
}

// ----------------------------------------------------
// ⚡️ 이벤트 리스너 등록 (document에 move/end 등록)
// ----------------------------------------------------

// 마우스 이벤트: 캔버스에서 시작, 어디서든 이동/끝
canvas.addEventListener("mousedown", handleDragStart);
document.addEventListener("mousemove", handleDragMove); // document로 변경
document.addEventListener("mouseup", handleDragEnd); 

// 터치 이벤트: 캔버스에서 시작, 어디서든 이동/끝
canvas.addEventListener("touchstart", handleDragStart);
document.addEventListener("touchmove", handleDragMove); // document로 변경
document.addEventListener("touchend", handleDragEnd); 


// ----------------------------------------------------
// 🧩 퍼즐 완성 및 애니메이션 로직 (기존과 동일)
// ----------------------------------------------------

// 퍼즐 완성 체크 및 애니메이션 함수
function checkAllPlaced() {
  if (puzzlePieces.filter(p => p.placed).length === 6) {
    canvas.style.pointerEvents = 'none'; // 더 이상 클릭 불가
    
    setTimeout(() => {
      successSound.currentTime = 0; 
      successSound.play(); 
      startWipeAnimation(); // 애니메이션 실행
    }, 500);
  }
}

// '닦아내기' 애니메이션 함수
function startWipeAnimation() {
  let wipeProgress = 0;
  const duration = 120; 
  let frame = 0;

  function animateWipe() {
    frame++;
    if (frame > duration) {
      // 캔버스 중앙에 메시지 띄우기 (옵션)
      winOverlay.style.display = 'flex';
      winMessage.textContent = "퍼즐 완성!";
      return;
    }

    wipeProgress = bgWidth * (frame / duration);

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 완성된 이미지 그리기
    ctx.drawImage(winImg, canvasBgOffsetX, yOffset, bgWidth, bgHeight);
    
    // 닦아내는 효과 (흰색 사각형으로 가리기)
    let clipX = canvasBgOffsetX + wipeProgress;
    let clipW = bgWidth - wipeProgress;
    
    ctx.fillStyle = 'white'; 
    ctx.fillRect(clipX, yOffset, clipW, bgHeight);

    requestAnimationFrame(animateWipe);
  }

  if (winImg.complete) {
    animateWipe();
  } else {
    winImg.onload = animateWipe;
  }
}


// 이미지 로드 후 그리기
let loadedCount = 0;
const totalImages = 1 + puzzleImgs.length + 1; 
function checkLoaded() {
  loadedCount++;
  if (loadedCount === totalImages) draw();
}
backgroundImg.onload = checkLoaded;
winImg.onload = checkLoaded;
puzzleImgs.forEach(img => img.onload = checkLoaded);
</script>
</body>
</html>
