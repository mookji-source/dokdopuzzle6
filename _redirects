<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>í¼ì¦ ë§ì¶”ê¸° ê²Œì„ (6ì¡°ê°)</title>
<style>
Â  body {
Â  Â  background-color: #f0f8ff;
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  Â  min-height: 100vh; /* í™”ë©´ ì „ì²´ ë†’ì´ ì‚¬ìš© */
Â  Â  margin: 0;
Â  Â  overflow: hidden;
Â  Â  flex-direction: column; /* ìº”ë²„ìŠ¤ì™€ ë¬¸êµ¬ë¥¼ ì„¸ë¡œë¡œ ë°°ì¹˜ */
Â  Â  position: relative;
Â  }
Â  #gameCanvas {
Â  Â  background-color: white;
Â  Â  border: none;
Â  Â  border-radius: 16px;
Â  Â  display: block;
Â  Â  margin: 0 auto;
Â  Â  z-index: 10;
Â  }

Â  /* ìŠ¹ë¦¬ ë©”ì‹œì§€ ì˜¤ë²„ë ˆì´ ìŠ¤íƒ€ì¼ (ë¬¸êµ¬ ì‚­ì œë¡œ ì‚¬ìš©ë˜ì§€ ì•Šìœ¼ë‚˜, ì¶”í›„ ì¬ì‚¬ìš©ì„ ìœ„í•´ ë‚¨ê²¨ë‘ ) */
Â  #winOverlay {
Â  Â  display: none; /* ğŸš¨ ì‚¬ìš©í•˜ì§€ ì•Šë”ë¼ë„ ì´ˆê¸° ìˆ¨ê¹€ ìœ ì§€ */
Â  Â  width: 1200px;
Â  Â  margin-top: 20px;
Â  Â  z-index: 20; 
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  Â  flex-direction: column;
Â  Â  text-align: center; 
Â  }
Â  #winMessage {
Â  Â  color: #0b3b8c; 
Â  Â  font-size: 48px; 
Â  Â  font-family: 'Arial Black', sans-serif;
Â  Â  padding: 20px 40px;
Â  Â  border-radius: 10px;
Â  Â  background-color: rgba(255, 255, 255, 0.9);
Â  Â  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
Â  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="1200" height="700"></canvas>

<div id="winOverlay" style="display: none;">
    <div id="winMessage"></div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const winOverlay = document.getElementById("winOverlay");

// ì´ë¯¸ì§€ ë¡œë“œ
const backgroundImg = new Image();
backgroundImg.src = "./images/background.png";

const puzzleImgs = [];
for (let i = 1; i <= 6; i++) {
Â  const img = new Image();
Â  img.src = `./images/puzzle${i}.png`;
Â  puzzleImgs.push(img);
}
const winImg = new Image();
winImg.src = "./images/win.png";

// ì‚¬ìš´ë“œ ë¡œë“œ ğŸš¨ ëª¨ë“  ì‚¬ìš´ë“œ ë³€ìˆ˜ ì‚­ì œë¨

// í¬ê¸° ë¹„ìœ¨
const scale = 0.35;
const bgWidth = 1920 * scale;
const bgHeight = 1078 * scale;
const puzzleWidth = 604 * scale;
const puzzleHeight = 508 * scale;

// í¼ì¦ ì •ë‹µ ìœ„ì¹˜
const yOffset = 20; // ë‚´ë ¤ì£¼ëŠ” ì •ë„ (ì›í•˜ëŠ” ë§Œí¼ ì¡°ì • ê°€ëŠ¥)
const canvasBgOffsetX = (canvas.width - bgWidth) / 2; // ìº”ë²„ìŠ¤ ì¤‘ì•™ ì •ë ¬ ê¸°ì¤€

const targetPositions = [
Â  {x: 38*scale + canvasBgOffsetX, y: 27*scale + yOffset},
Â  {x: (38+604+23)*scale + canvasBgOffsetX, y: 27*scale + yOffset},
Â  {x: (38+604+23+604+19)*scale + canvasBgOffsetX, y: 27*scale + yOffset},
Â  {x: 38*scale + canvasBgOffsetX, y: (27+508+15)*scale + yOffset},
Â  {x: (38+604+23)*scale + canvasBgOffsetX, y: (27+508+15)*scale + yOffset},
Â  {x: (38+604+23+604+19)*scale + canvasBgOffsetX, y: (27+508+15)*scale + yOffset},
];

// í•˜ë‹¨ ê²¹ì³ì§„ ê¸°ë³¸ ìœ„ì¹˜
const basePieceStartX = 50;
const basePieceStartY = canvas.height - puzzleHeight - 30;
const pieceSpacing = 10;

const basePositions = [];
for (let i = 0; i < 6; i++) {
    basePositions.push({
        x: basePieceStartX + (i * (puzzleWidth + pieceSpacing)),
        y: basePieceStartY
    });
}


// ë¬´ì‘ìœ„ ì„ê¸°
function shuffle(array) {
Â  for (let i = array.length - 1; i > 0; i--) {
Â  Â  const j = Math.floor(Math.random() * (i + 1));
Â  Â  [array[i], array[j]] = [array[j], array[i]];
Â  }
Â  return array;
}

const shuffledOriginalIndices = shuffle(Array.from({length: 6}, (_, i) => i));

// í¼ì¦ ì´ˆê¸° ìœ„ì¹˜ë¥¼ ì„ì¸ ì›ë³¸ ì¸ë±ìŠ¤ì— ë”°ë¼ ë°°ì¹˜
const puzzlePieces = shuffledOriginalIndices.map((originalIndex, shuffledPosIndex) => ({
Â  x: basePositions[shuffledPosIndex].x,
Â  y: basePositions[shuffledPosIndex].y,
Â  originalIndex: originalIndex,
Â  placed: false
}));

let dragging = false;
let dragIndex = -1;
let offsetDragX = 0, offsetDragY = 0;

function draw() {
Â  ctx.clearRect(0, 0, canvas.width, canvas.height);
Â  // ë°°ê²½ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
Â  ctx.drawImage(backgroundImg, canvasBgOffsetX, yOffset, bgWidth, bgHeight);
Â  
Â  // í¼ì¦ ì¡°ê° ê·¸ë¦¬ê¸°
Â  puzzlePieces.forEach((p) => {
Â  Â  const img = puzzleImgs[p.originalIndex];
Â  Â  ctx.drawImage(img, p.x, p.y, puzzleWidth, puzzleHeight);
Â  });
}

// ë“œë˜ê·¸ ì‹œì‘
canvas.addEventListener("mousedown", e => {
Â  const mx = e.offsetX, my = e.offsetY;
Â  let found = false;

Â  for (let i = puzzlePieces.length - 1; i >= 0; i--) {
Â  Â  const p = puzzlePieces[i];
Â  Â  if (p.placed) continue;

Â  Â  if (mx >= p.x && mx <= p.x + puzzleWidth &&
Â  Â  Â  Â  my >= p.y && my <= p.y + puzzleHeight) {
Â  Â  Â  dragging = true;
Â  Â  Â  
Â  Â  Â  const pieceToDrag = puzzlePieces.splice(i, 1)[0];
Â  Â  Â  puzzlePieces.push(pieceToDrag);
Â  Â  Â  dragIndex = puzzlePieces.length - 1;
Â  Â  Â  
Â  Â  Â  offsetDragX = mx - pieceToDrag.x;
Â  Â  Â  offsetDragY = my - pieceToDrag.y;
Â  Â  Â  found = true;
Â  Â  Â  break;
Â  Â  }
Â  }
Â  if (found) draw();
});

// ë“œë˜ê·¸ ì¤‘
canvas.addEventListener("mousemove", e => {
Â  if (dragging && dragIndex !== -1) {
Â  Â  const mx = e.offsetX, my = e.offsetY;
Â  Â  puzzlePieces[dragIndex].x = mx - offsetDragX;
Â  Â  puzzlePieces[dragIndex].y = my - offsetDragY;
Â  Â  draw();
Â  }
});

// ë“œë˜ê·¸ ë
canvas.addEventListener("mouseup", () => {
Â  if (dragging && dragIndex !== -1) {
Â  Â  const piece = puzzlePieces[dragIndex];
Â  Â  const target = targetPositions[piece.originalIndex];

Â  Â  const dx = piece.x - target.x;
Â  Â  const dy = piece.y - target.y;
Â  Â  const distance = Math.sqrt(dx * dx + dy * dy);

Â  Â  const snapTolerance = 40;

Â  Â  if (distance < snapTolerance) {
Â  Â  Â  // âœ… ì •ë‹µ ìœ„ì¹˜ ìŠ¤ëƒ…
Â  Â  Â  piece.x = target.x;
Â  Â  Â  piece.y = target.y;
Â  Â  Â  piece.placed = true;
Â  Â  Â  // successSound.play(); ğŸš¨ ì‚­ì œ
Â  Â  Â  checkAllPlaced();
Â  Â  } else {
Â  Â  Â  // âŒ ì˜¤ë‹µ, ì›ë˜ ìë¦¬ë¡œ ë³µê·€
Â  Â  Â  // fallSound.play(); ğŸš¨ ì‚­ì œ

Â  Â  Â  const startX = piece.x;
Â  Â  Â  const startY = piece.y;
Â  Â  Â  
Â  Â  Â  const originalBasePos = basePositions[shuffledOriginalIndices.indexOf(piece.originalIndex)];
      const endX = originalBasePos.x;
      const endY = originalBasePos.y;
      
Â  Â  Â  let progress = 0;

Â  Â  Â  function returnAnim() {
Â  Â  Â  Â  progress += 0.1;
Â  Â  Â  Â  piece.x = startX + (endX - startX) * progress;
Â  Â  Â  Â  piece.y = startY + (endY - startY) * progress;
Â  Â  Â  Â  draw();
Â  Â  Â  Â  if (progress < 1) requestAnimationFrame(returnAnim);
Â  Â  Â  }
Â  Â  Â  requestAnimationFrame(returnAnim);
Â  Â  }
Â  }
Â  dragging = false;
Â  dragIndex = -1;
Â  draw();
});

// í¼ì¦ ì™„ì„± ì²´í¬ ë° ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜
function checkAllPlaced() {
Â  if (puzzlePieces.filter(p => p.placed).length === 6) {
Â  Â  canvas.style.pointerEvents = 'none'; // ë” ì´ìƒ í´ë¦­ ë¶ˆê°€
Â  Â  
Â  Â  setTimeout(() => {
Â  Â  Â  // successSound.play(); ğŸš¨ ì‚­ì œ
Â  Â  Â  startWipeAnimation(); // ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰
Â  Â  }, 500);
Â  }
}

// 'ë‹¦ì•„ë‚´ê¸°' ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜
function startWipeAnimation() {
Â  let wipeProgress = 0;
Â  const duration = 120; // ì• ë‹ˆë©”ì´ì…˜ ì§€ì† ì‹œê°„ (í”„ë ˆì„ ë‹¨ìœ„)
Â  let frame = 0;

Â  function animateWipe() {
Â  Â  frame++;
Â  Â  if (frame > duration) {
Â  Â  Â  // ì• ë‹ˆë©”ì´ì…˜ ì¢…ë£Œ í›„ ë¬¸êµ¬ ë° ì‚¬ìš´ë“œ ì¬ìƒ ğŸš¨ ëª¨ë‘ ì‚­ì œ
Â  Â  Â  /*
Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  winOverlay.style.display = 'flex';
Â  Â  Â  Â  Â  Â  seagullsSound.play();
Â  Â  Â  Â  Â  Â  seaSound.play();
Â  Â  Â  Â  }, 100);
      */
Â  Â  Â  return;
Â  Â  }

Â  Â  wipeProgress = bgWidth * (frame / duration);

Â  Â  ctx.clearRect(0, 0, canvas.width, canvas.height);
Â  Â  
Â  Â  // ì™„ì„±ëœ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
Â  Â  ctx.drawImage(winImg, canvasBgOffsetX, yOffset, bgWidth, bgHeight);
Â  Â  
Â  Â  // ë‹¦ì•„ë‚´ëŠ” íš¨ê³¼ (í°ìƒ‰ ì‚¬ê°í˜•ìœ¼ë¡œ ê°€ë¦¬ê¸°)
Â  Â  let clipX = canvasBgOffsetX + wipeProgress;
Â  Â  let clipW = bgWidth - wipeProgress;
Â  Â  
Â  Â  ctx.fillStyle = 'white'; 
Â  Â  ctx.fillRect(clipX, yOffset, clipW, bgHeight);

Â  Â  requestAnimationFrame(animateWipe);
Â  }

Â  if (winImg.complete) {
Â  Â  animateWipe();
Â  } else {
Â  Â  winImg.onload = animateWipe;
Â  }
}


// ì´ë¯¸ì§€ ë¡œë“œ í›„ ê·¸ë¦¬ê¸°
let loadedCount = 0;
const totalImages = 1 + puzzleImgs.length + 1; // background, puzzle 6ê°œ, win 1ê°œ
function checkLoaded() {
Â  loadedCount++;
Â  if (loadedCount === totalImages) draw();
}
backgroundImg.onload = checkLoaded;
winImg.onload = checkLoaded;
puzzleImgs.forEach(img => img.onload = checkLoaded);
</script>
</body>
</html>
/*    /index.html   200
